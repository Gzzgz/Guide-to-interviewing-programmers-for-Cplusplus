/*
【名称】40亿个非负整数中找到没有出现的数
【题目】32位无符号整数的范围是0-4294967295，现在有一个正好包含40亿个无
符号整数的文件，所以在整个范围中必然有没有出现过的数。可能使用最多1GB
内存，怎么找到所有没有出现过的数？
进阶：内存限制为10MB，但是只用找到一个没有出现过的数即可。
【难度】尉
*/

/*
原问题：申请一个长度为4294967295的bit类型的数组bitArr，占用500M空间；遍历40
亿个无符号数，遇到所有的数时，就把bitArr相应位置的值置为1.遍历完成后，
再依次遍历bitArr，哪个位置上没有设置为1，就不在40亿个数中。

进阶问题：将0-4294967295这个范围平均分为64个区间，每个区间67109964个数，
第一次遍历，先申请长度为64的整型数组countArr[0...63]，用来统计区间i上的
数有多少。遍历40亿个数，依据当前数是多少来决定哪一个区间上的计数增加。
遍历40亿个数后，遍历countArr，必然会有某一个位置上的值小于67108864;
然后申请长度为67108864的bitmap，再遍历依次40亿个数，此时遍历只关注落在
countArr[i]<67108864的区间中的数，如果有数num在该区间上，将bitmap[num - 67108864 * i]
的值设置为1；遍历完40亿个数后，遍历bitmap未被设置为1的位置j，那么67108864 * i + j
就是未出现过的数。

*/