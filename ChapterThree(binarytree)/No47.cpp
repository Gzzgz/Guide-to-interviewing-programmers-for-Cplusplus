/*
【名称】在二叉树中找到一个节点的后继节点
【题目】现在有一种新的二叉树节点类型如下：
class Node{
public:
    int value;
	Node left;
	Node right;
	Node parent;
};
该结构比普通二叉树节点结构多了一个指向父节点的parent指针。假设
有一棵Node类型的节点组成的二叉树，树中每个节点的parent指针都正确
地指向自己的父节点，头节点的parent指向null。只给一个在二叉树中
的某个节点node,请实现返回node的后继节点的函数，在二叉树的中序遍历
的序列中，node的下一个节点叫作node的后继节点。
【难度】尉
*/
#include <iostream>

struct Node{
	int value;
	Node* left;
	Node* right;
	Node* parent;
	Node(int value):value(value),left(nullptr),right(nullptr),parent(nullptr) {}
};

Node* getLeftMost(Node* node) {
	if (node == nullptr) {
		return node;
	}
	while (node->left != nullptr) {
		node = node->left;
	}
	return node;
}

Node* getNextNode(Node* node) {
	if (node == nullptr) {
		return node;
	}
	if (node->right != nullptr) {
		return getLeftMost(node->right);
	}
	else {
		Node * parent = node->parent;
		while (parent != nullptr && parent->left != node) {
			node = parent;
			parent = node->parent;
		}
		return parent;
	}
}

int main() {

	Node* head = new Node(6);
	head->left = new Node(3);
	head->left->parent = head;
	head->right = new Node(9);
	head->right->parent = head;
	head->right->left = new Node(8);
	head->right->left->parent = head->right;
	head->right->right = new Node(10);
	head->right->right->parent = head->right;
	head->right->left->left = new Node(7);
	head->right->left->left->parent = head->right->left;
	head->left->left = new Node(1);
	head->left->left->parent = head->left;
	head->left->right = new Node(4);
	head->left->right->parent = head->left;
	head->left->right->right = new Node(5);
	head->left->right->right->parent = head->left->right;
	head->left->left->right = new Node(2);
	head->left->left->right->parent = head->left->left;

	head = getNextNode(head->right);
	std::cout << head->value << std::endl;

	return 0;
}